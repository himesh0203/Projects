Device-side simulator (MQTT publisher)

# device_simulator.py
import json
import random
import time
from datetime import datetime, timezone
import paho.mqtt.client as mqtt

BROKER = "localhost"  # Change to your broker URL/IP
PORT = 1883
PATIENT_ID = "patient_001"
TOPIC = f"rpm/{PATIENT_ID}/vitals"

def generate_vitals():
    return {
        "patient_id": PATIENT_ID,
        "timestamp": datetime.now(timezone.utc).isoformat(),
        "heart_rate_bpm": random.randint(55, 110),
        "spo2_percent": random.randint(90, 100),
        "systolic_mmHg": random.randint(95, 150),
        "diastolic_mmHg": random.randint(60, 95),
        "temperature_c": round(random.uniform(36.2, 38.5), 1),
        "device_id": "sim-hr-01",
        "firmware": "1.0.0"
    }

def main():
    client = mqtt.Client(client_id=f"device-{PATIENT_ID}", clean_session=True)
    client.connect(BROKER, PORT, keepalive=60)
    client.loop_start()
    try:
        while True:
            msg = generate_vitals()
            payload = json.dumps(msg)
            client.publish(TOPIC, payload=payload, qos=1, retain=False)
            print(f"Published: {payload}")
            time.sleep(5)  # every 5 seconds
    except KeyboardInterrupt:
        print("Stopping simulator...")
    finally:
        client.loop_stop()
        client.disconnect()

if __name__ == "__main__":
    main()







Backend service (FastAPI + MQTT consumer + SQLite)
# backend.py
import json
import sqlite3
import threading
from datetime import datetime
from typing import Optional, Dict, Any, List

from fastapi import FastAPI, HTTPException
from pydantic import BaseModel, Field, validator
import uvicorn
import paho.mqtt.client as mqtt

DB_PATH = "rpm.db"
BROKER = "localhost"
PORT = 1883
SUB_TOPIC = "rpm/+/vitals"  # subscribe to all patients

# ---------- Data model ----------

class VitalReading(BaseModel):
    patient_id: str = Field(..., min_length=1, max_length=64)
    timestamp: str
    heart_rate_bpm: int = Field(..., ge=20, le=250)
    spo2_percent: int = Field(..., ge=50, le=100)
    systolic_mmHg: int = Field(..., ge=50, le=250)
    diastolic_mmHg: int = Field(..., ge=30, le=150)
    temperature_c: float = Field(..., ge=30.0, le=45.0)
    device_id: Optional[str] = Field(default=None, max_length=64)
    firmware: Optional[str] = Field(default=None, max_length=32)

    @validator("timestamp")
    def validate_timestamp(cls, v):
        try:
            # Allow ISO format
            datetime.fromisoformat(v.replace("Z", "+00:00"))
            return v
        except Exception:
            raise ValueError("Invalid ISO timestamp")

# ---------- DB setup ----------

def init_db():
    conn = sqlite3.connect(DB_PATH)
    conn.execute("""
    CREATE TABLE IF NOT EXISTS readings (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        patient_id TEXT NOT NULL,
        timestamp TEXT NOT NULL,
        heart_rate_bpm INTEGER NOT NULL,
        spo2_percent INTEGER NOT NULL,
        systolic_mmHg INTEGER NOT NULL,
        diastolic_mmHg INTEGER NOT NULL,
        temperature_c REAL NOT NULL,
        device_id TEXT,
        firmware TEXT
    );
    """)
    conn.execute("""
    CREATE TABLE IF NOT EXISTS alerts (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        patient_id TEXT NOT NULL,
        timestamp TEXT NOT NULL,
        type TEXT NOT NULL,
        message TEXT NOT NULL,
        reading_id INTEGER,
        FOREIGN KEY(reading_id) REFERENCES readings(id)
    );
    """)
    conn.commit()
    conn.close()

def insert_reading(v: VitalReading) -> int:
    conn = sqlite3.connect(DB_PATH)
    cur = conn.cursor()
    cur.execute("""
    INSERT INTO readings (patient_id, timestamp, heart_rate_bpm, spo2_percent,
                          systolic_mmHg, diastolic_mmHg, temperature_c, device_id, firmware)
    VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
    """, (
        v.patient_id, v.timestamp, v.heart_rate_bpm, v.spo2_percent,
        v.systolic_mmHg, v.diastolic_mmHg, v.temperature_c, v.device_id, v.firmware
    ))
    reading_id = cur.lastrowid
    conn.commit()
    conn.close()
    return reading_id

def insert_alert(patient_id: str, alert_type: str, message: str, reading_id: Optional[int]):
    conn = sqlite3.connect(DB_PATH)
    conn.execute("""
    INSERT INTO alerts (patient_id, timestamp, type, message, reading_id)
    VALUES (?, datetime('now'), ?, ?, ?)
    """, (patient_id, alert_type, message, reading_id))
    conn.commit()
    conn.close()

# ---------- Alert logic ----------

def evaluate_alerts(v: VitalReading, reading_id: int):
    alerts: List[Dict[str, Any]] = []

    if v.spo2_percent < 92:
        alerts.append(("oxygen", f"Low SpO₂: {v.spo2_percent}%",))
    if v.heart_rate_bpm < 50 or v.heart_rate_bpm > 110:
        alerts.append(("heart_rate", f"Abnormal HR: {v.heart_rate_bpm} bpm",))
    if v.temperature_c >= 38.0:
        alerts.append(("temperature", f"Fever suspected: {v.temperature_c} °C",))
    if v.systolic_mmHg >= 140 or v.diastolic_mmHg >= 90:
        alerts.append(("blood_pressure", f"High BP: {v.systolic_mmHg}/{v.diastolic_mmHg} mmHg",))

    for alert_type, message in alerts:
        insert_alert(v.patient_id, alert_type, message, reading_id)
        # Hook: send_notification(patient_id, alert_type, message)

# ---------- MQTT consumer ----------

def on_connect(client, userdata, flags, rc):
    print("MQTT connected:", rc)
    client.subscribe(SUB_TOPIC, qos=1)

def on_message(client, userdata, msg):
    try:
        data = json.loads(msg.payload.decode("utf-8"))
        v = VitalReading(**data)  # validation
        reading_id = insert_reading(v)
        evaluate_alerts(v, reading_id)
        print(f"Ingested reading for {v.patient_id} (id={reading_id})")
    except Exception as e:
        print("Ingestion error:", e)

def start_mqtt():
    client = mqtt.Client(client_id="backend-consumer", clean_session=True)
    client.on_connect = on_connect
    client.on_message = on_message
    client.connect(BROKER, PORT, keepalive=60)
    client.loop_forever()

# ---------- FastAPI ----------

app = FastAPI(title="RPM Backend", version="1.0.0")

class ReadingResponse(BaseModel):
    id: int
    patient_id: str
    timestamp: str
    heart_rate_bpm: int
    spo2_percent: int
    systolic_mmHg: int
    diastolic_mmHg: int
    temperature_c: float
    device_id: Optional[str]
    firmware: Optional[str]

class AlertResponse(BaseModel):
    id: int
    patient_id: str
    timestamp: str
    type: str
    message: str
    reading_id: Optional[int]

@app.get("/patients/{patient_id}/readings/latest", response_model=ReadingResponse)
def get_latest_reading(patient_id: str):
    conn = sqlite3.connect(DB_PATH)
    cur = conn.cursor()
    cur.execute("""
    SELECT id, patient_id, timestamp, heart_rate_bpm, spo2_percent,
           systolic_mmHg, diastolic_mmHg, temperature_c, device_id, firmware
    FROM readings
    WHERE patient_id = ?
    ORDER BY datetime(timestamp) DESC, id DESC
    LIMIT 1
    """, (patient_id,))
    row = cur.fetchone()
    conn.close()
    if not row:
        raise HTTPException(status_code=404, detail="No readings found")
    keys = ["id","patient_id","timestamp","heart_rate_bpm","spo2_percent",
            "systolic_mmHg","diastolic_mmHg","temperature_c","device_id","firmware"]
    return dict(zip(keys, row))

@app.get("/patients/{patient_id}/alerts", response_model=list[AlertResponse])
def get_alerts(patient_id: str):
    conn = sqlite3.connect(DB_PATH)
    cur = conn.cursor()
    cur.execute("""
    SELECT id, patient_id, timestamp, type, message, reading_id
    FROM alerts
    WHERE patient_id = ?
    ORDER BY datetime(timestamp) DESC, id DESC
    LIMIT 100
    """, (patient_id,))
    rows = cur.fetchall()
    conn.close()
    keys = ["id", "patient_id", "timestamp", "type", "message", "reading_id"]
    return [dict(zip(keys, r)) for r in rows]

@app.get("/health")
def health():
    return {"status": "ok"}

def main():
    init_db()
    t = threading.Thread(target=start_mqtt, daemon=True)
    t.start()
    uvicorn.run(app, host="0.0.0.0", port=8000)

if __name__ == "__main__":
    main()




Requirements
text
# requirements.txt
fastapi==0.115.0
uvicorn[standard]==0.32.0
pydantic==1.10.15
paho-mqtt==1.6.1
Tip: Use Python 3.10+ and create a virtual environment. Install an MQTT broker (e.g., Mosquitto) locally: set it to listen on port 1883.



Running everything
Start broker: Install and run Mosquitto (or any MQTT broker) on your machine.

Run backend:

python backend.py

Backend exposes HTTP on port 8000 and subscribes to MQTT.

Run simulator:

python device_simulator.py

Observe published messages; backend will ingest and alert.

Check data:

GET http://localhost:8000/patients/patient_001/readings/latest

GET http://localhost:8000/patients/patient_001/alerts


