Password strength checker
# password_strength.py
import re

def password_score(pw: str) -> int:
    score = 0
    length = len(pw)

    # Length scoring
    if length >= 12: score += 3
    elif length >= 10: score += 2
    elif length >= 8: score += 1

    # Character variety
    if re.search(r"[a-z]", pw): score += 1
    if re.search(r"[A-Z]", pw): score += 1
    if re.search(r"[0-9]", pw): score += 1
    if re.search(r"[^A-Za-z0-9]", pw): score += 1

    # Penalties
    common = {"password","123456","qwerty","letmein","admin","welcome"}
    if pw.lower() in common: score = max(0, score - 4)
    if re.fullmatch(r"(.)\1{7,}", pw): score = max(0, score - 3)  # repeated chars

    return score

def classify(score: int) -> str:
    return ("weak" if score <= 3 else
            "medium" if score <= 6 else
            "strong")

if __name__ == "__main__":
    pw = input("Enter password to evaluate: ")
    s = password_score(pw)
    print(f"Score: {s} | Strength: {classify(s)}")
    print("Tip: Use 12+ chars, mix upper/lower/digits/symbols, avoid common words.")




TCP port scanner (synopsis)

# port_scanner.py
import socket
from concurrent.futures import ThreadPoolExecutor

def scan_host(host: str, ports: list[int], timeout: float = 0.5) -> dict[int, bool]:
    results = {}
    for p in ports:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            s.settimeout(timeout)
            try:
                s.connect((host, p))
                results[p] = True
            except Exception:
                results[p] = False
    return results

def scan_fast(host: str, start: int = 1, end: int = 1024, workers: int = 100):
    ports = list(range(start, end + 1))
    open_ports = []

    def check(p):
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            s.settimeout(0.3)
            try:
                s.connect((host, p))
                return p
            except Exception:
                return None

    with ThreadPoolExecutor(max_workers=workers) as ex:
        for res in ex.map(check, ports):
            if res is not None:
                open_ports.append(res)
    return open_ports

if __name__ == "__main__":
    target = input("Target host/IP: ").strip()
    opens = scan_fast(target, 1, 1024)
    print(f"Open ports on {target}: {opens}")


Log brute-force detection (auth logs)

# brute_force_detector.py
from datetime import datetime, timedelta
from collections import defaultdict
import re

LOG_PATH = "/var/log/auth.log"  # change per OS
WINDOW_MIN = 10
THRESHOLD = 10

FAILED_PATTERNS = [
    r"Failed password for .* from (?P<ip>\d{1,3}(?:\.\d{1,3}){3})",
    r"Invalid user .* from (?P<ip>\d{1,3}(?:\.\d{1,3}){3})",
]

def parse_time(line: str) -> datetime | None:
    # Example: "Nov 12 14:21:03 hostname sshd[123]: Failed password ..."
    try:
        ts = line[:15]
        dt = datetime.strptime(ts, "%b %d %H:%M:%S")
        # Year is missing; assume current year
        return dt.replace(year=datetime.now().year)
    except Exception:
        return None

def detect():
    events = defaultdict(list)
    with open(LOG_PATH, "r", errors="ignore") as f:
        for line in f:
            for pat in FAILED_PATTERNS:
                m = re.search(pat, line)
                if m:
                    ip = m.group("ip")
                    t = parse_time(line) or datetime.now()
                    events[ip].append(t)

    now = datetime.now()
    suspects = []
    for ip, times in events.items():
        times = [t for t in times if now - t <= timedelta(minutes=WINDOW_MIN)]
        if len(times) >= THRESHOLD:
            suspects.append((ip, len(times)))

    return sorted(suspects, key=lambda x: x[1], reverse=True)

if __name__ == "__main__":
    res = detect()
    if not res:
        print("No brute-force patterns detected in the last window.")
    else:
        print("Potential brute-force sources:")
        for ip, count in res:
            print(f"- {ip} -> {count} failed attempts in {WINDOW_MIN} minutes")



File integrity monitoring (hash baseline)
# file_integrity.py
import os
import json
import hashlib
from pathlib import Path

BASELINE = Path("baseline_hashes.json")

def sha256(path: Path) -> str:
    h = hashlib.sha256()
    with open(path, "rb") as f:
        for chunk in iter(lambda: f.read(8192), b""):
            h.update(chunk)
    return h.hexdigest()

def build_baseline(root: Path):
    data = {}
    for p in root.rglob("*"):
        if p.is_file():
            data[str(p)] = sha256(p)
    BASELINE.write_text(json.dumps(data, indent=2))
    print(f"Baseline saved with {len(data)} files.")

def check_integrity(root: Path):
    if not BASELINE.exists():
        print("No baseline. Run with --init first.")
        return
    old = json.loads(BASELINE.read_text())
    modified, missing, new = [], [], []
    current = {}
    for p in root.rglob("*"):
        if p.is_file():
            current[str(p)] = sha256(p)
    for path, digest in old.items():
        if path not in current:
            missing.append(path)
        elif current[path] != digest:
            modified.append(path)
    for path in current.keys():
        if path not in old:
            new.append(path)
    print(f"Modified: {len(modified)} | Missing: {len(missing)} | New: {len(new)}")
    for m in modified[:10]:
        print("MOD:", m)
    for m in missing[:10]:
        print("MISS:", m)
    for n in new[:10]:
        print("NEW:", n)

if __name__ == "__main__":
    import argparse
    ap = argparse.ArgumentParser()
    ap.add_argument("--root", type=str, default=".", help="Directory to monitor")
    ap.add_argument("--init", action="store_true", help="Create baseline")
    args = ap.parse_args()

    root = Path(args.root).resolve()
    if args.init:
        build_baseline(root)
    else:
        check_integrity(root)


Simple file encryption and decryption (Fernet)
# crypto_tool.py
from cryptography.fernet import Fernet
import argparse

def gen_key(file="secret.key"):
    key = Fernet.generate_key()
    with open(file, "wb") as f:
        f.write(key)
    print(f"Key saved to {file}")

def load_key(file="secret.key"):
    with open(file, "rb") as f:
        return f.read()

def encrypt(in_file: str, out_file: str, key_file="secret.key"):
    f = Fernet(load_key(key_file))
    data = open(in_file, "rb").read()
    enc = f.encrypt(data)
    open(out_file, "wb").write(enc)
    print(f"Encrypted {in_file} -> {out_file}")

def decrypt(in_file: str, out_file: str, key_file="secret.key"):
    f = Fernet(load_key(key_file))
    data = open(in_file, "rb").read()
    dec = f.decrypt(data)
    open(out_file, "wb").write(dec)
    print(f"Decrypted {in_file} -> {out_file}")

if __name__ == "__main__":
    ap = argparse.ArgumentParser()
    ap.add_argument("--genkey", action="store_true")
    ap.add_argument("--enc", nargs=2, metavar=("IN", "OUT"))
    ap.add_argument("--dec", nargs=2, metavar=("IN", "OUT"))
    ap.add_argument("--key", default="secret.key")
    args = ap.parse_args()

    if args.genkey:
        gen_key(args.key)
    elif args.enc:
        encrypt(args.enc[0], args.enc[1], args.key)
    elif args.dec:
        decrypt(args.dec[0], args.dec[1], args.key)
    else:
        print("Use --genkey or --enc IN OUT or --dec IN OUT")



Requirements:

text
cryptography==43.0.0



Basic packet sniffer (needs admin privileges)

# packet_sniffer.py
from scapy.all import sniff, IP, TCP

def handler(pkt):
    if IP in pkt:
        src = pkt[IP].src
        dst = pkt[IP].dst
        proto = "TCP" if TCP in pkt else pkt[IP].proto
        print(f"{src} -> {dst} | {proto}")

if __name__ == "__main__":
    # On Linux/macOS may need sudo. On Windows, run as admin.
    print("Sniffing first 50 packets on interface (default)...")
    sniff(prn=handler, count=50, store=False)



Requirements:

text
scapy==2.5.0


